for each table T:
  tables:
    # Pickup all dim_product checks, 3 in total
    - dim_product%
  checks:
    - row_count > 0

for each table R:
  tables:
    - dim_product_%
  checks:
    - row_count(english_product_category_name) > 0


checks for dim_product:
  - schema:
      name: Look for required columns
      warn:
        when required column missing: [weight_unit_measure_code, product_subcategory_key, made_up_column]
      fail:
        when required column missing: [product_key, product_alternate_key]
  - schema:
      name: Find forbidden or wrong type
      warn:
        when forbidden column present: [standard_cost]
        when wrong column type:
          standard_cost: money
      fail:
        when forbidden column present: [sombrero]
        when wrong column type:
          reorder_point: smallint
  - schema:
      name: Columns out of order
      warn:
        when wrong column index:
          style: 1
      fail:
        when wrong column index:
          model_name: 22
  - schema:
      name: Any schema changes
      warn: 
        when schema changes: any
  - schema:
      fail:
        when schema changes:
          - column delete
          - column add
          - column index change
          - column type change
  - freshness using start_date < 3d
  - freshness using end_date:
      warn: when > 3d
# Doesn't work; filters do not apply to freshness checks
#  - freshness using end_date < 3d:
#      filter: standard_cost > 0
# Doesn't work; name is not registered by Soda Core nor send to Soda Cloud
#  - freshness using start_date < 27h:
#      name: Data is fresh

checks for dim_reseller:
  - duplicate_count(last_order_year) = 0
  - duplicate_count(first_order_year):
      name: First year duplicates exist
      warn: when > 0
      fail: when > 100    
  - duplicate_count(last_order_year) = 0:
      name: Last year duplicates exist
  - avg_order_span between 5 and 10:
      avg_order_span expression: AVG(last_order_year - first_order_year)

checks for dim_employee:
  - max(vacation_hours) < 80:
      name: Too many vaccation hours for sales territory US
      filter: sales_territory_key = 11
  - min(pay_frequency) >= 0
  - max(pay_frequency) <= 5000
  - avg(vacation_hours) between 50 and 100
  - sum(vacation_hours) < 20000
  - stddev(vacation_hours) between 20 and 30
  - stddev_pop(vacation_hours) between 20 and 30
  - stddev_samp(vacation_hours) between 20 and 30
  - variance(vacation_hours) between 800 and 900
  - var_pop(vacation_hours) between 800 and 900
  - var_samp(vacation_hours) between 800 and 900
  - percentile(vacation_hours, 0.95) > 90
  
checks for dim_organization:
  - row_count = 10.0:
      filter: parent_organization_key = 1
  - row_count < 11
  - row_count > 9
  - row_count <= 10
  - row_count >= 10
  - row_count != 0
  - row_count <> 0
  - row_count between 10 and 15
  - row_count between -5 and 10
  - row_count between (9 and 15]
  - row_count between [-5 and 11)
  - row_count not between 11 and 15
  - row_count not between -5 and 9
  - row_count not between (10 and 15
  - row_count not between -5 and 10)

checks for dim_customer:
  - min_length(suffix) < 4
  - max_length(suffix) = 3
  - avg_length(suffix) >= 3
  - invalid_count(total_children) = 0:
      valid min: 6
  - invalid_percent(total_children) = 0:
      valid max: 6
  - missing_count(birth_date) = 0
  - missing_percent(gender) < 5%
# Doesn't work but it's a valid error. This is because data type date is not considered TEXT.
#  - invalid_count(birth_date) > 0:
#      valid regex: .*
#  - invalid_count(birth_date) > 0:
#      valid regex: ^\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$
# Doesn't work but it's a valid error. This is because data type money is not considered TEXT.
#  - invalid_count(yearly_income) = 0:
#      valid format: money
# Doesn't work but it's a valid error. This is because data type date is not considered TEXT.
#  - invalid_count(date_first_purchase) = 0:
#      valid format: date eu
  - invalid_count(email_address) = 0:
      valid format: email
  - invalid_count(last_name) = 0:
      valid format: uuid
  - invalid_count(last_name) = 0:
      valid format: date eu
  - invalid_percent(last_name) > 5:
      valid regex: ^\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$
  - missing_count(middle_name) = 0:
      missing regex: ^\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$
  - missing_count(first_name) < 5:
      missing values: [Antonio, Aaron]
  - missing_percent(email_address) = 0:
      valid format: email
  - missing_count(last_name) < 5:
      missing values: [n/a, NA, none]
  - missing_count(french_occupation) = 0:
      missing regex: (0?[0-9]|1[012])[/](0?[0-9]|[12][0-9]|3[01])[/](0000|(19|20)?\d\d)
  - invalid_count(number_cars_owned):
      valid min: 1
      name: Car ownership
      warn: when > 3
      fail: when = 0
  - invalid_percent(marital_status):
      valid length: 1
      name: Marital status
      warn: when < 5
      fail: when > 5
  - invalid_percent(marital_status) = 0:
      valid max length: 10
  - invalid_percent(marital_status) = 0:
      valid min length: 1
  - invalid_count(first_name) = 0:
      valid values: [Antonio]
  - row_count same as dim_department_group:
      name: Silly comparison
  - row_count same as retail_orders in aws_postgres_retail:
      name: Baloney comparison
  - values in total_children must exist in dim_employee pay_frequency:
      name: Bogus x-check %%
  - values in (phone, house_owner_flag) must exist in dim_employee (emergency_contact_phone, gender):
      name: Weirdo comparison
  - failed rows:
      name: Failed rows with CTE
      fail condition: total_children = '2' and number_cars_owned >= 3
  - failed rows:
      name: Failed rows query test
      fail query: |
        SELECT DISTINCT geography_key
        FROM dim_customer as customer
  - anomaly score for row_count < default
# Doesn't work, errors for each of the following
#  - change for row_count < 5
#  - change avg last 7 days row_count < 50
#  - change min last 7 days row_count < 50
#  - change max last 7 days row_count < 50


# Doesn't work, errors
#filter dim_product [daily]:
#  where: TIMESTAMP '${start_date}' <= "ts" AND "ts" < TIMESTAMP '${end_date}'

#checks for dim_product [daily]:
# - row_count = 6

# Works but doesn't send to cloud; 400 error because no dataset is identified in the check key
#checks:
#  - failed rows:
#      name: Failed rows query test
#      fail query: |
#        SELECT *
#        FROM dim_customer as customer

# Works independently in a separate file, and doesn't send to cloud; 400 error because no dataset is identified in the check key
#checks:
#  - avg_nonsense between 2000 and 5000:
#      avg_nonsense query: |
#        SELECT AVG(first_order_year * last_order_year) as avg_nonsense
#        FROM dim_reseller


# Removed all "valid" metrics as they are replaced by "invalid".
#  - valid_count(total_children) = 0:
#      valid values: [50, 100, 2303]
# Doesn't work; Unsupported metric
#  - valid_percent(total_children) = 0:
#      valid values: [50, 100, 2303]
#  - valid_count(email_address) > 10:
#      valid min length: 6
#  - valid_count(email_address) > 1:
#      valid max length: 6
#  - valid_count(email_address) > 5:
#      valid length: 6